1) Проще будет реализовать первый сигнал, потому что он не зависит от самого себя, в то время как второй сигнал зависит от двух предыдущих значений, что будет создавать зависимость между потоками.
2) Так как по условию номер WorkItem по оси X меняется чаще всего, то в пределах warpа с размером 32 `get_local_id(1)` будет постоянным. При этом `get_local_size(1)` также является константой, причем равной 32 (исходя из размеров WorkGroup в условии). Получается, что часть `get_local_size(1) * get_local_id(0)` всегда будет давать остаток 0 при делении на 32, значит ее можно "убрать" из суммы. Получается, что маскирование будет зависеть от `get_local_id(1)`, которая, как уже было сказано, константна для варпа. Значит code divergence не будет.
3) 
   a. Внутри варпа `get_local_size(0)` и `get_local_id(1)` будут постоянными (рассуждения схожи с рассуждениями в пункте 2), а меняться будет только `get_local_id(0)` от 0 до 31. Получается, что обращения к памяти будут **coalesced**, при этом влезут на **одну кэш линию** (32 * sizeof(float)). 
   b. Тут снова `get_local_size(0)` и `get_local_id(1)` будут постоянными внутри варпа, но из-за того, что теперь `get_local_id(0)` не слагаемое, а множитель, то получатеся, что запись будет происходить раз в 32 ячейки. Получается, что обращения **не coalesced**. Каждый поток будет использовать свою кэшлинию (потому что блоки по 32 не пересекаются), поэтому будет использовано **32 кэш линии**.
   c. Тут практически идентичный случай с пунктом "а", но сдвиг на 1 собьет выравнивание по 128 байт, поэтому придется использовать **две кэш линии**. При этом обращения к памяти все еще можно назвать **частично coalesced**.
   